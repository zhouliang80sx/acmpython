# -*- coding: utf-8 -*-
"""
Created on Wed Aug 15 11:07:36 2018

@author: user
"""
'''
https://blog.csdn.net/runninglion/article/details/17338409
分析：显然对于此题，加括号的作用是改变运算的顺序，
所以就不用考虑 +和 * 号本身的运算优先级了，
只需把精力放在表达式的分割上。
可以看出，这个问题和著名的矩阵连乘问题是非常相似的。
矩阵连乘问题的求解过程：设a[i .. j]表示 i、j区间内所有矩阵相乘所需的最小数乘次数，
则必有 a[i .. j] = a[i .. k] * a[k+1 .. j] (i <= k < j)，
因为矩阵的数乘次数只与它们的行列数有关。
而题的求解思路和矩阵连乘的求解思路是一样的，也是从部分解推导出整个运算的结果。

注意两个负数相乘的结果是正数，故它们可能大于只用正数求解的结果，
但是只有做运算的两负数都尽可能的小，才能使结果尽可能的大。
为了解决表达式中有负数的问题，需要多加一个 dp矩阵，用于保存最大值和最小值。



https://segmentfault.com/a/1190000003939663
给定一个整数数组，要求在数字之间任意添加乘号，加号和括号，
使得最后表达式结果最大。
比如1121,最大值为(1+1)*(2+1)，这里数字可以是0或者负数。


https://blog.csdn.net/u010372095/article/details/46573329
CF E. Vanya and Brackets(添加一对括号使得表达式的值最大)


'''

